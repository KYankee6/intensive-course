# 10. 그래프 이론

그래프 이론 장에서 주로 다룰 내용은 다음과 같습니다.

> 0. DFS/BFS/Shortest-Path
> 1. 유니온-파인드(상호 배타적/서로소 집합, Disjoint Set)
> 2. 최소 신장 트리(크루스칼 알고리즘)
> 3. 위상 정렬 알고리즘

부록(기타 알고리즘)은 따로 정리할 예정입니다.

---

## 10-1. 이미 배운 내용을 훑어보자.

#### 이미 배운 내용

- DFS/BFS
- 최단 경로

#### 앞으로 배울 내용

- 크루스칼 알고리즘 (그리디)
- 위상정렬 알고리즘 (큐/스택 자료구조 이용)

#### 10-1-1. 그래프(Graph)

그래프란 노드(Node)와 노드 사이에 연결된 간선(Edge)의 정보를 가지고 있는 `자료구조`를 의미한다.

> 알고리즘 문제를 접했을 때 서로 다른 개체(객체)가 연결되어 있다는 이야기를 들으면 가장 먼저 그래프 알고리즘을 떠올려야 한다.
> ex) 여러 개의 도시가 도로로 연결되어 있다 ....
> N개의 집을 방문하려는데, 도로로 연결되어 있다...
> 축제로 가는 최단 경로를 찾는데 각 마을마다 도로로 연결 되어있다...

그래프의 구현 방법은 2가지 방법이 존재한다.

**인접 행렬(Adjacency Matrix)**

- 2차원 배열을 사용하는 방식
- 소요 메모리: $O(V^2)$
- 소요 접근 시간: $O(1)$

**인접 리스트(Adjacency List)**

- 리스트를 사용하는 방식
- 소요 메모리: $O(E)$
- 소요 접근 시간: $O(V)$

9장에서 우선순위 큐를 이용하는 `다익스트라 최단 경로 알고리즘`은 인접 리스트를 이용하는 방식이다. 노드의 개수가 V개일 때는 V개의 리스트를 만들어 각 노드와 연결된 모든 간선에 대한 정보를 리스트에 저장했다.

반면 `플로이드 워셜` 알고리즘은 인접 행렬을 이용하는 방식이다. 모든 노드에 대하여 다른 노드로 가는 최소 비용을 $V^2$크기의 2차원 리스트에 저장한 뒤에 해당 비용을 갱신해서 최단 거리를 계산했다.

어떤 문제를 만나든 `메모리`와 `시간`을 염두에 두고 알고리즘을 선택, 구현해야 한다.
예를 들어 `최단 경로` 문제를 만났을 때, 노드의 개수가 적다면 `플로이드 워셜` 알고리즘을 이용할 수 있다. 반면에 노드와 간선 개수가 많으면 `다익스트라` 알고리즘을 이용하면 유리하다.

### 10-1-2.트리(Tree)

`다익스트라 최단 경로 알고리즘`에는 우선순위 큐가 사용되었는데, 우선 순위 큐를 구현하기 위해 최소 힙/최대 힙 자료구조를 이용할 수 있다고 했다.

> 힙(Heap) 자료구조
> 최소 힙은 항상 부모노드가 자식 노드보다 크기가 작다.
> 최대 힙은 항상 부모노드가 자식 노드보다 크기가 크다.
> 참고로, 트리는 전통적인 수학에서는 무방향이지만, 컴퓨터공학 분야에서는 보통 방향 그래프로 간주한다.

|                     | 그래프                         | 트리             |
| ------------------- | ------------------------------ | ---------------- |
| 방향성              | 방향 그래프 혹은 무방향 그래프 | 방향 그래프      |
| 순환성              | 순환 및 비순환                 | 비순환           |
| 루트 노드 존재 여부 | 루트 노드가 없음               | 루트 노드가 존재 |
| 노드간 관계성       | 부모와 자식 관계 없음          | 부모와 자식 관계 |
| 모델의 종류         | 네트워크 모델                  | 계층 모델        |

## 10-2 기타 그래프 알고리즘

### 10-2-1. 서로소 집합(Disjoint Sets)

- 공통 원소가 없는 두 집합을 의미한다.
- $given A=\{1,2\}, B=\{3,4\}$
- $A \cap B = \emptyset$
- A와 B는 서로소 관계이다.

서로소 집합 자료구조(Union-Find 자료구조)

- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조 (무느알?)
- 서로소 집합 자료구조는 `union`, `find` 로 조작할 수 있다.
- `union` 연산은 2개의 원소가 포함된 하나의 집합으로 합치는 연산이다.
- `find` 연산은 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다.

서로소 집합 자료구조를 구현할 때에는 `트리` 자료구조를 이용하여 집합을 표현한다.
서로소 집합 정보가 주어졌을 때 집합을 표현하는 서로소 집합 계산 알고리즘은 다음과 같다.

> 서로소 집합 계산 알고리즘
>
> 1. union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.
>    1-1. A와 B의 루트 노드 A', B'를 각각 찾는다
>    1-2. A'를 B'의 부모 노드로 설정한다. (B'가 A'를 가르키도록 한다).
> 2. 모든 union(합집합) 연산을 처리할 때 까지 1번 과정을 반복한다.

실제로 구현할 때는 A'와 B'중 `더 번호가 작은 원소`가 부모 노드가 되도록 구현하는 경우가 많다.

```python
# 기본적인 서로소 집합 알고리즘
def find_parent(parent, x):
    if parent[x] != x:
        return find_parent(parent, parent[x])
    else:
        return x

def union_parent(parent, a, b):
    a = find_parent(a)
    b = find_parent(b)

    if a < b:
        parent[b] = a
    else:
        parent[a] = b


v, e = map(int, input().split())
parent = [0] * (v + 1)

for i in range(1, v + 1):
    parent[i] = i

for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent,a,b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합: ')
for i in range(1, v+1):
    print(find_parent(parent,i), end=' ')
  
print()

# 부모 테이블 출력
print('부모 테이블: ')
for i in range(1,v+1):
    print(parent[i], end=' ')
```

다만, 이렇게 구현한다면 find 함수가 비효율적으로 동작한다.
최악의 경우 find 함수가 모든 노드를 다 확인하여 $O(V)$가 된다.
결과 적으로 현재 알고리즘을 그대로 이용하게 되면 노드의 개수가 V개고, find/union 연산의 개수가 M개일 때 전체 시간 복잡도는 $O(VM)$이 되어 비효율적이다.

하지만 `경로 압축 기법`을 적용하면 시간 복잡도를 개선시킬 수 있다.

```python
# 경로 압축 기법 소스코드
def adv_find_parent(parent, x):
    if parent[x] != x:
        parent[x]=find_parent(parent, parent[x])
    return parent[x]
```

![](https://velog.velcdn.com/images/petit-prince/post/bc7125bc-8310-43ed-8e21-8fcff17eb03e/image.png "경로 압축 설명")

#### 10-2-2. 서로소 집합 알고리즘의 시간 복잡도

- 노드의 개수가 V개
- 최대 V-1개의 union 연산과 M개의 find 연산
- (경로 압축 적용) $O(V+M(1+log_{2-M/V}{V}))$$\approx O(V+Mlog_2V)$

### 10-2-3. 서로소 집합을 활용한 사이클 판별

**무방향** 그래프 내에서의 사이클을 판별할 때 사용할 수 있다.

> 방향 그래프에서는 DFS를 사용하여 사이클을 판별 할 수 있다.

사이클 판별하는 과정은 다음과 같다.

> 1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
>    1-1. 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.
>    1-2. 루트 노드가 서로 같다면 사이클(Cycle)이 발생한 것이다.
> 2. 그래프에 포함되어 있는 모든 간선에 대하여 '1번' 과정을 반복한다.

## 10-3. 신장 트리

신장 트리(Spanning Tree)란 하나의 그래프가 있을 때 **모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프**를 의마한다.
이때 모든 노드가 포함되어 **서로 연결**되면서 **사이클이 존재하지 않는다**는 조건은 트리의 성립 조건이기도 하다.

### 10-3-1. 크루스칼 알고리즘

N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 전체 도시가 서로 연결 될 수 있게 도로를 설치하는 경우를 생각해보자. 2개의 도시 A,B를 선택했을때, 도시 A에서 도시 B로 이동하는 경로가 반드시 존재하도록 도로를 설치하고자 한다. 모든 도시를 '연결'할 때 최소한의 비용으로 연결하려면 어떤 알고리즘을 이용해야 할까?
이때 사용되는 것이 `크루스칼` 알고리즘이다.
크루스칼 알고리즘은 그리디 알고리즘으로 분류된다.

> 1. 간선 데이터를 비용에 따라 오름차순으로 정렬한다.
> 2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.
>    2-1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
>    2-2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
> 3. 모든 간선에 대하여 2번의 과정을 반복한다.

최소 신장트리는 일종의 트리 자료구조이므로, 간선의 개수가 '노드의 개수 - 1'과 같다는 특징이 있다.
따라서 크루스칼 알고리즘의 핵심 원리는 가장 거리가 짧은 간선부터 차례대로 집합에 추가하면 된다는 것이다. 다만, 사이클을 발생시키는 간선은 제외한다.
이렇게하면 항상 `최적해`를 보장할 수 있다.

```python
# 경로 압축 사용
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    else:
        return x

def union_parent(parent, a, b):
    a = find_parent(a)
    b = find_parent(b)

    if a < b:
        parent[b] = a
    else:
        parent[a] = b


v, e = map(int, input().split())
parent = [0] * (v + 1)

for i in range(1, v + 1):
    parent[i] = i

edges = []
result = 0

for _ in range(e):
    a, b, cost = map(int, input().split())
    edges.append({cost,a,b})
  
edges.sort()

for edge in edges:
    cost, a, b = edge
    if find_parent(parent, a)!= find_parent(parent,b):
        union_parent(parent,a,b)
        result+=cost

print(result)
```

> 다시 생각해보는 거지만 python의 구조분해할당?(언팩) 저게 좀 사기다
> cpp는 tuple<int,int,int>를 선언하고 get\<N>(Object)로 받아야하는데
> C++ 17부터는 이를 지원한다고는 하나 코딩테스트에서 C++ 17을 지원 해줄 까 ㅠ

### 10-3-2. 크루스칼 알고리즘의 시간 복잡도

- 간선의 개수가 E개일 때
- $O(ElogE)$
- 이는 전적으로 간선을 정렬 할 때 걸리는 시간 복잡도(퀵 소트)에 의존적이다.

## 10-4. 위상 정렬

위상 정렬(Topology Sort)는 정렬 알고리즘의 일정이다.

- 순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있는 알고리즘
- 방향 그래프의 모든 노드를 **방향성에 거스르지 않도록 순서대로 나열하는 것**이다.
- ex) 선수과목을 고려한 학습 순서 설정
- 진입 차수(Indegree), 특정한 노드로 '들어오는' 간선의 개수를 의미한다.

위상 정렬의 알고리즘은 다음과 같다.

> 1. 진입차수가 0인 노드를 큐에 넣는다.
> 2. 큐가 빌때까지 다음의 과정을 반복한다.
>    2-1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
>    2-2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.

이때 모든 원소를 방문하기 전에 큐가 빈다면, 사이클이 존재한다고 판단할 수 있다.
다시 말해 큐에서 **원소가 V번 추출되기 전에 큐가 비어버리면** 사이클이 발생한 것이다.
사이클이 존재하는 경우 사이클에 포함되어 있는 원소 중에서 어떠한 원소도 큐에 들어가지 못하기 때문이다.

```python
# 위상 정렬 소스코드
from collections import deque

v, e = map(int, input().split())

# 진입 차수 0으로 초기화
indegree = [0] * (v + 1)

# 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트(그래프) 초기화
graph = [[] for i in range(v + 1)]

for _ in range(e):
    a, b = map(int, input().split())
    graph[a].append(b)
    indegree[b] += 1


def topology_sort():
    result = []
    q = deque()
  
    for i in range(1, v+1):
        if indegree[i] == 0 :
            q.append(i)
    while q:
        now = q.popleft()
        result.append(now)
        for i in graph[now]:
            indegree[i]-=1
            if indegree[i]==0:
                q.append(i)
              
    for i in result:
        print(i,end=' ')
  
topology_sort()
```

위상 정렬의 시간 복잡도는 $O(V+E)$이다.

- 차례대로 모든 노드륵 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거해야 한다.
- 결과적으로 노드와 간선을 모두 확인한다는 측면에서 $O(V+E)$의 시간이 소요된다.
